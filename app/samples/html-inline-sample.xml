<?xml version="1.0" encoding="utf-8"?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Test XMLSpectrum</title>
</head>
<body>
<h1>XSLT Code Sample</h1>
<p> The following XSLT is colorised  as XSLT because the <code>samp</code> element
has a <code>lang</code> attribute with value 'xslt'.</p>
<samp lang="xslt"><![CDATA[
<xsl:variable name="className">
    <xsl:choose>
        <xsl:when test="exists(@type)">
            <xsl:value-of
                            select="if (@type eq 'literal' and
                            matches(@value ,
                            'select[\n\p{Zs}]*=[\n\p{Zs}]*[&quot;&apos;&apos;]')
                            )
                            then 'select' else @type"
                            />
        </xsl:when>
        <xsl:otherwise>
            <xsl:variable name="p" select="$para[$index - 1] "/>
            <xsl:value-of
                            select="if ($p/@type eq 'literal' and                           
                            matches(
                            $p/@value ,
                            'name[\n\p{Zs}]*=[\n\p{Zs}]*[&quot;&apos;&apos;]')
                            )
                            then 'external'
                            else 'qname'"
            />
        </xsl:otherwise>
    </xsl:choose>
</xsl:variable>]]>
</samp>
<p>Some more text.</p>
<h1>XSD Code Sample</h1>
<p> The following XSD is colorised  as XSLT because the <code>samp</code> element
has a <code>lang</code> attribute with value 'xsd'.</p>
<samp lang="xsd"><![CDATA[
<xs:element name="price">
 <xs:complexType>
   <xs:sequence>
     <xs:element name="value" maxOccurs="unbounded">
        <xs:complexType>
          <xs:simpleContent>
            <xs:extension base="xs:double">
              <xs:attribute name="effective" type="xs:date" use="required"/>
              <xs:attribute name="freeware" type="xs:boolean"/>
              <xs:attribute name="format" use="required">
                <xs:simpleType>
                  <xs:restriction base="xs:string">
                    <xs:enumeration value="hard cover"/>
                    <xs:enumeration value="pdf"/>
                  </xs:restriction>
                </xs:simpleType>
              </xs:attribute>
              <xs:assert test="@effective lt current-date()" />
              <xs:assert test="if (@freeware eq true()) then (@format eq 'pdf' and . eq 0)
                               else true()" />                    
            </xs:extension>
          </xs:simpleContent>
        </xs:complexType>
     </xs:element>
   </xs:sequence>
   <xs:assert test="every $vl in value[position() lt last()] satisfies
                    ($vl gt $vl/following-sibling::value[1]) and 
                    ($vl/@effective lt $vl/following-sibling::value[1]/@effective)" />
 </xs:complexType>
</xs:element>]]>
</samp>
<p>Some more text.</p>

<h1>XPathCode Sample</h1>
<p> The following XSLT is colorised as XPath because the <code>samp</code> element
in the source has a <code>lang</code> attribute of  'xpath'.</p>
<samp lang="xpath"><![CDATA[
if (@type eq 'literal' and
    matches(
            @value ,
            'select[\n\p{Zs}]*=[\n\p{Zs}]*[&quot;&apos;&apos;]')
           )
then 'select' else @type]]>
</samp>
<p>Some more text.</p>
</body>
</html>
